<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Trading Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Basic reset and font */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0d1117; /* Dark space background */
            font-family: 'Inter', sans-serif;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            flex-direction: column;
            gap: 20px;
        }

        /* Game Container */
        .game-container {
            position: relative;
            width: 90vw; /* Responsive width */
            max-width: 1200px; /* Max width for larger screens */
            height: 70vh; /* Responsive height */
            max-height: 800px; /* Max height */
            border: 2px solid #4a4a4a;
            border-radius: 10px;
            overflow: hidden;
            background-color: #000; /* Inner game background */
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3); /* Neon glow */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        /* Canvas styling */
        canvas {
            display: block;
            background-color: #000; /* Ensure canvas background is black */
            width: 100%;
            height: 100%;
        }

        /* UI Panel */
        .game-ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #333;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
            z-index: 10;
            font-size: 0.9em;
            color: #a0a0a0;
        }

        .game-ui div {
            margin-bottom: 5px;
        }

        /* Radar Canvas */
        #radarCanvas {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 150px; /* Fixed size for radar */
            height: 150px;
            border: 1px solid #00ffff; /* Cyan border */
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.7);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
            z-index: 10;
        }

        /* Messages */
        #message-box {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid #555;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.3); /* Yellow glow for messages */
            color: #fff;
            font-size: 1.1em;
            text-align: center;
            min-width: 200px;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            pointer-events: none; /* Allow clicks to pass through */
            z-index: 100;
            display: flex; /* Added for vertical stacking */
            flex-direction: column; /* Added for vertical stacking */
            align-items: center; /* Center items horizontally */
            gap: 10px; /* Space between message and button */
        }

        #message-box.show {
            opacity: 1;
        }

        #message-box.game-over {
            opacity: 1; /* Keep visible indefinitely */
            pointer-events: all; /* Allow clicks on button */
        }

        #message-box button {
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            display: none; /* Hidden by default */
        }

        #message-box button:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }

        #message-box button:active {
            transform: translateY(0);
        }

        /* Pause message */
        #pause-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 10px;
            border: 2px solid #00ffff;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            color: #00ffff;
            font-size: 2.5em;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            z-index: 200;
            display: none; /* Hidden by default */
        }


        /* Menu Styles (Planet and Shipyard) */
        .menu-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #1a1a1a;
            border: 2px solid #00ffff; /* Cyan border */
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            z-index: 20;
            width: 80%;
            max-width: 700px;
            max-height: 90%;
            overflow-y: auto;
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 20px;
        }

        .menu-container h2 {
            color: #00ffff;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.8em;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.7);
        }

        .menu-sections {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: space-around;
        }

        .menu-section {
            flex: 1;
            min-width: 280px;
            background-color: #2a2a2a;
            border: 1px solid #008888;
            border-radius: 8px;
            padding: 15px;
            box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.1);
        }

        .menu-section h3 {
            color: #00ffaa;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.3em;
            border-bottom: 1px solid #006666;
            padding-bottom: 5px;
        }

        .item-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .item-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px dashed #3a3a3a;
        }

        .item-list li:last-child {
            border-bottom: none;
        }

        .item-list span {
            flex: 1;
        }

        .item-list button {
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 0.85em;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            margin-left: 5px; /* Space between buttons */
        }

        .item-list button:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }

        .item-list button:active {
            transform: translateY(0);
        }

        .not-purchased-label {
            color: #888;
            font-style: italic;
            padding: 6px 12px;
            font-size: 0.85em;
            text-align: right;
            min-width: 100px; /* Ensure consistent width */
        }

        .menu-close-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 1.1em;
            margin-top: 20px;
            align-self: center;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
        }

        .menu-close-btn:hover {
            background-color: #c82333;
            transform: translateY(-2px);
        }

        .menu-close-btn:active {
            transform: translateY(0);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .game-container {
                width: 95vw;
                height: 60vh;
            }

            .menu-container {
                width: 95%;
                padding: 15px;
            }

            .menu-sections {
                flex-direction: column;
            }

            .menu-section {
                min-width: unset;
                width: 100%;
            }

            .game-ui {
                font-size: 0.8em;
                padding: 8px 12px;
            }

            #radarCanvas {
                width: 100px;
                height: 100px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <canvas id="radarCanvas"></canvas>
        <div class="game-ui">
            <div>Credits: <span id="credits-display">0</span></div>
            <div>Cargo: <span id="cargo-display">0</span> / <span id="max-cargo-display"></span></div>
            <div>Shield: <span id="shield-display">100</span></div>
            <div>Hull: <span id="hull-display">100</span></div>
        </div>
        <div id="message-box">
            <span id="message-text"></span>
            <button id="play-again-button" onclick="restartGame()">Play Again</button>
        </div>

        <div id="pause-message">(P)AUSED</div>

        <div id="planet-menu" class="menu-container">
            <h2 id="planet-name-display"></h2>
            <div class="menu-credits">Credits: <span id="planet-credits-display">0</span></div>
            <div class="menu-sections">
                <div class="menu-section">
                    <h3>Buy Goods</h3>
                    <ul id="buy-list" class="item-list">
                        </ul>
                </div>
                <div class="menu-section">
                    <h3>Sell Goods</h3>
                    <ul id="sell-list" class="item-list">
                        </ul>
                </div>
            </div>
            <button class="menu-close-btn" onclick="closePlanetMenu()">Leave Orbit (E)</button>
        </div>

        <div id="shipyard-menu" class="menu-container">
            <h2 id="shipyard-name-display"></h2>
            <div class="menu-credits">Credits: <span id="shipyard-credits-display">0</span></div>
            <div class="menu-sections">
                <div class="menu-section">
                    <h3>Repairs & Upgrades</h3>
                    <ul id="upgrade-list" class="item-list">
                        </ul>
                </div>
            </div>
            <button class="menu-close-btn" onclick="closeShipyardMenu()">Leave Shipyard (E)</button>
        </div>
    </div>

    <script>
        // Get canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const radarCanvas = document.getElementById('radarCanvas'); // Get radar canvas
        const radarCtx = radarCanvas.getContext('2d'); // Get radar context

        // UI elements
        const creditsDisplay = document.getElementById('credits-display');
        const cargoDisplay = document.getElementById('cargo-display');
        const maxCargoDisplay = document.getElementById('max-cargo-display');
        const shieldDisplay = document.getElementById('shield-display');
        const hullDisplay = document.getElementById('hull-display'); // Get hull display element
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text'); // Span for message text
        const playAgainButton = document.getElementById('play-again-button'); // Play Again button
        const pauseMessage = document.getElementById('pause-message'); // Pause message element

        // Menus
        const planetMenu = document.getElementById('planet-menu');
        const planetNameDisplay = document.getElementById('planet-name-display');
        const planetCreditsDisplay = document.getElementById('planet-credits-display'); // New planet credits display
        const buyList = document.getElementById('buy-list');
        const sellList = document.getElementById('sell-list');

        const shipyardMenu = document.getElementById('shipyard-menu'); // New shipyard menu
        const shipyardNameDisplay = document.getElementById('shipyard-name-display'); // New shipyard name display
        const shipyardCreditsDisplay = document.getElementById('shipyard-credits-display'); // New shipyard credits display
        const upgradeList = document.getElementById('upgrade-list'); // New upgrade list

        // Game constants
        const PLAYER_MAX_SPEED_BASE = 3; // Base max speed
        const PLAYER_ROTATION_SPEED_BASE = 0.05; // Base rotation speed
        const PLAYER_ACCELERATION_BASE = 0.1; // Base acceleration

        const PROJECTILE_SPEED = 8;
        const PROJECTILE_LIFESPAN = 60; // frames
        const PROJECTILE_DAMAGE_BASE = 30; // Base weapon damage

        const ASTEROID_SPEED = 2;
        const ASTEROID_SPAWN_INTERVAL = 120; // frames
        const ASTEROID_MAX_COUNT = 15;
        const ASTEROID_SIZE_MIN = 10;
        const ASTEROID_SIZE_MAX = 50;
        const ASTEROID_MIN_SPLIT_RADIUS = 20;
        const NUM_SPLIT_ASTEROIDS = 2; // Number of smaller asteroids to spawn
        const SPLIT_ASTEROID_RADIUS_FACTOR = 0.6; // New radius = parent radius * factor
        const SPLIT_ASTEROID_SPEED_FACTOR = 1.5; // New speed = factor for random scatter velocity
        const ORE_SIZE = 10;
        const ORE_PICKUP_RADIUS = 30;
        const ORE_LIFESPAN = 300; // frames
        const PLAYER_CARGO_CAPACITY_BASE = 10; // Base cargo capacity
        const PLANET_RADIUS = 60;
        const PLANET_PROXIMITY_RADIUS = 150;
        const PLANET_MAX_COUNT = 3; // Max number of planets in space
        const SPACE_STATION_RADIUS = 80; // Larger than planets
        const SPACE_STATION_PROXIMITY_RADIUS = 200;
        const SPACE_STATION_MAX_COUNT = 1; // Only one space station for now
        const MESSAGE_DURATION = 2000; // ms
        const SHOT_COOLDOWN_BASE = 15; // Base fire rate

        // Asteroid Health and Hit Force
        const COPPER_ASTEROID_HEALTH = 300;
        const IRON_ASTEROID_HEALTH = 500;
        const ICE_ASTEROID_HEALTH = 100;
        const ASTEROID_COLLISION_ENERGY_FACTOR = 0.000025; // Factor to convert collision energy to shield damage

        // Player Shield and Hull constants
        const PLAYER_INITIAL_SHIELD_BASE = 100;
        const PLAYER_SHIELD_RECHARGE_RATE = 0.2; // Shield points per frame
        const SHIELD_HIT_EFFECT_DURATION = 30; // Frames for shield visual effect
        const PLAYER_INITIAL_HULL_BASE = 250; // Initial hull strength (stronger than shield)

        // World dimensions (approx. 10 times larger area than canvas)
        const WORLD_SCALE_FACTOR = 7; // Changed from 3.5 to 7 to double world dimensions
        let WORLD_WIDTH;
        let WORLD_HEIGHT;

        // Radar constants
        const RADAR_DOT_SIZE = 3; // Size of dots on radar
        let RADAR_SCALE_FACTOR_X; // Calculated based on world width and radar canvas width
        let RADAR_SCALE_FACTOR_Y; // Calculated based on world height and radar canvas height

        // Economic constants
        const PLANET_STOCK_REGENERATION_RATE = 0.1; // Amount of stock regenerated per interval
        const PLANET_STOCK_REGENERATION_INTERVAL = 30; // Frames between stock regeneration updates
        const PLANET_SELL_BACK_FACTOR = 0.8; // Player sells goods back to planet for 80% of buy price

        // Game state variables
        let gameFrame = 0;
        let player;
        let projectiles = [];
        let asteroids = [];
        let ores = [];
        let planets = [];
        let spaceStations = []; // New array for space stations
        let keys = {};
        let lastShotFrame = 0;
        let currentPlanet = null;
        let currentSpaceStation = null; // New current station variable
        let dockableTargetCandidate = null; // New variable to hold the potential dockable target
        let isGameOver = false; // New game state flag

        // New pause state variables
        let isGamePaused = false; // True if game logic should stop
        let isUserPaused = false; // True if user pressed P/Escape
        let isMenuOpen = false; // True if planet or shipyard menu is open

        let animationFrameId = null; // To store the requestAnimationFrame ID

        // Starfield variables
        let stars = [];
        const NUM_STARS = 50; // Number of stars in the background

        // Item definitions (name, base price)
        const ITEMS = {
            'Copper Ore': { basePrice: 10 },
            'Iron Ore': { basePrice: 25 },
            'Water Ice': { basePrice: 5 },
            'Food Rations': { basePrice: 20 },
            'Medical Supplies': { basePrice: 50 },
            'Luxury Goods': { basePrice: 100 },
            'Rare Metals': { basePrice: 75 },
            'Advanced Components': { basePrice: 120 },
            'Alien Artifacts': { basePrice: 500 },
            'Fuel Cells': { basePrice: 15 },
            'Textiles': { basePrice: 30 },
            'Spices': { basePrice: 45 },
            'Fine Art': { basePrice: 300 },
            'Robotics': { basePrice: 180 },
            'Synthetics': { basePrice: 25 },
            'Gems': { basePrice: 250 }
        };

        // Upgrade definitions
        const UPGRADES = {
            'Hull Repair': {
                costPerUnit: 1, // Credits per hull point
                apply: (amount) => {
                    // Ensure amount is not negative and does not exceed missing hull
                    const hullToRepair = Math.min(amount, player.maxHull - player.hull);
                    const cost = hullToRepair * UPGRADES['Hull Repair'].costPerUnit;
                    if (player.credits >= cost && hullToRepair > 0) {
                        player.credits -= cost;
                        player.hull += hullToRepair;
                        showMessage(`Repaired ${hullToRepair.toFixed(0)} hull for ${cost} credits.`);
                        return true;
                    } else if (hullToRepair === 0) {
                        showMessage("Hull is already full!");
                    } else {
                        showMessage("Not enough credits for repair!");
                    }
                    return false;
                },
                display: () => `Repair all hull damage. Cost: ${(player.maxHull - player.hull).toFixed(0)} Cr (1 Cr/point)`
            },
            'Cargo Space': {
                cost: 100,
                increment: 5,
                apply: () => {
                    if (player.credits >= UPGRADES['Cargo Space'].cost) {
                        player.credits -= UPGRADES['Cargo Space'].cost;
                        player.maxCargo += UPGRADES['Cargo Space'].increment;
                        player.updateCargoWeight(); // Recalculate cargo weight after max increases
                        showMessage(`Cargo space upgraded to ${player.maxCargo}!`);
                        return true;
                    } else {
                        showMessage("Not enough credits for cargo upgrade!");
                    }
                    return false;
                },
                display: () => `Upgrade cargo space (+${UPGRADES['Cargo Space'].increment}). Current: ${player.maxCargo}. Cost: ${UPGRADES['Cargo Space'].cost} Cr`
            },
            'Shield Strength': {
                cost: 150,
                increment: 25,
                apply: () => {
                    if (player.credits >= UPGRADES['Shield Strength'].cost) {
                        player.credits -= UPGRADES['Shield Strength'].cost;
                        player.maxShield += UPGRADES['Shield Strength'].increment;
                        player.shield = player.maxShield; // Fully recharge shield on upgrade
                        showMessage(`Shield strength upgraded to ${player.maxShield}!`);
                        return true;
                    } else {
                        showMessage("Not enough credits for shield upgrade!");
                    }
                    return false;
                },
                display: () => `Upgrade max shield (+${UPGRADES['Shield Strength'].increment}). Current: ${player.maxShield}. Cost: ${UPGRADES['Shield Strength'].cost} Cr`
            },
            'Weapon Fire Rate': {
                cost: 200,
                increment: 2, // Decrement cooldown by this amount
                apply: () => {
                    if (player.credits >= UPGRADES['Weapon Fire Rate'].cost) {
                        if (player.shotCooldown - UPGRADES['Weapon Fire Rate'].increment < 5) { // Minimum cooldown
                            showMessage("Fire rate is already maxed out!");
                            return false;
                        }
                        player.credits -= UPGRADES['Weapon Fire Rate'].cost;
                        player.shotCooldown -= UPGRADES['Weapon Fire Rate'].increment;
                        showMessage(`Fire rate upgraded! Cooldown: ${player.shotCooldown} frames.`);
                        return true;
                    } else {
                        showMessage("Not enough credits for fire rate upgrade!");
                    }
                    return false;
                },
                display: () => `Upgrade fire rate (-${UPGRADES['Weapon Fire Rate'].increment} frames cooldown). Current: ${player.shotCooldown} frames. Cost: ${UPGRADES['Weapon Fire Rate'].cost} Cr`
            },
            'Turn Rate': {
                cost: 120,
                increment: 0.01,
                max: 0.2, // Maximum turn rate
                apply: () => {
                    if (player.credits >= UPGRADES['Turn Rate'].cost) {
                        if (player.rotationSpeed + UPGRADES['Turn Rate'].increment > UPGRADES['Turn Rate'].max) {
                            showMessage("Turn rate is already maxed out!");
                            return false;
                        }
                        player.credits -= UPGRADES['Turn Rate'].cost;
                        player.rotationSpeed += UPGRADES['Turn Rate'].increment;
                        showMessage(`Turn rate upgraded! Current: ${player.rotationSpeed.toFixed(2)}.`);
                        return true;
                    } else {
                        showMessage("Not enough credits for turn rate upgrade!");
                    }
                    return false;
                },
                display: () => {
                    if (player.rotationSpeed + UPGRADES['Turn Rate'].increment > UPGRADES['Turn Rate'].max) {
                        return `Turn rate maxed out! Current: ${player.rotationSpeed.toFixed(2)}`;
                    }
                    return `Upgrade turn rate (+${UPGRADES['Turn Rate'].increment.toFixed(2)}). Current: ${player.rotationSpeed.toFixed(2)}. Cost: ${UPGRADES['Turn Rate'].cost} Cr`;
                }
            },
            'Ship Speed': {
                cost: 180,
                accelIncrement: 0.01,
                speedIncrement: 0.5,
                max: 10, // Maximum ship speed
                apply: () => {
                    if (player.credits >= UPGRADES['Ship Speed'].cost) {
                        if (player.maxSpeed + UPGRADES['Ship Speed'].speedIncrement > UPGRADES['Ship Speed'].max) {
                            showMessage("Ship speed is already maxed out!");
                            return false;
                        }
                        player.credits -= UPGRADES['Ship Speed'].cost;
                        player.acceleration += UPGRADES['Ship Speed'].accelIncrement;
                        player.maxSpeed += UPGRADES['Ship Speed'].speedIncrement;
                        showMessage(`Ship speed upgraded! Max Speed: ${player.maxSpeed.toFixed(1)}.`);
                        return true;
                    } else {
                        showMessage("Not enough credits for ship speed upgrade!");
                    }
                    return false;
                },
                display: () => {
                    if (player.maxSpeed + UPGRADES['Ship Speed'].speedIncrement > UPGRADES['Ship Speed'].max) {
                        return `Ship speed maxed out! Current: ${player.maxSpeed.toFixed(1)}`;
                    }
                    return `Upgrade ship speed (+${UPGRADES['Ship Speed'].speedIncrement.toFixed(1)} max speed). Current: ${player.maxSpeed.toFixed(1)}. Cost: ${UPGRADES['Ship Speed'].cost} Cr`;
                }
            },
            'Max Hull Strength': {
                cost: 200,
                increment: 50,
                apply: () => {
                    if (player.credits >= UPGRADES['Max Hull Strength'].cost) {
                        player.credits -= UPGRADES['Max Hull Strength'].cost;
                        player.maxHull += UPGRADES['Max Hull Strength'].increment;
                        player.hull = player.maxHull; // Fully repair hull on max hull upgrade
                        showMessage(`Max hull strength upgraded to ${player.maxHull}!`);
                        return true;
                    } else {
                        showMessage("Not enough credits for max hull upgrade!");
                    }
                    return false;
                },
                display: () => `Upgrade max hull (+${UPGRADES['Max Hull Strength'].increment}). Current: ${player.maxHull}. Cost: ${UPGRADES['Max Hull Strength'].cost} Cr`
            }
        };


        // Utility functions
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function getDistance(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function showMessage(text, duration = MESSAGE_DURATION) {
            if (isGameOver) return; // Don't show regular messages if game is over
            messageText.textContent = text;
            messageBox.classList.remove('game-over'); // Ensure game-over styling is removed
            messageBox.classList.add('show');
            playAgainButton.style.display = 'none'; // Hide play again button for regular messages
            // Clear any existing timeout before setting a new one
            if (messageBox.timeoutId) {
                clearTimeout(messageBox.timeoutId);
            }
            messageBox.timeoutId = setTimeout(() => {
                messageBox.classList.remove('show');
                messageBox.timeoutId = null;
            }, duration);
        }

        function showGameOverMessage(text) {
            isGameOver = true;
            messageText.textContent = text;
            messageBox.classList.add('show', 'game-over'); // Add game-over class to keep it visible
            playAgainButton.style.display = 'block'; // Show play again button
            if (messageBox.timeoutId) { // Clear any pending hide message
                clearTimeout(messageBox.timeoutId);
                messageBox.timeoutId = null;
            }
            // Stop the animation loop immediately when game is over
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        function hideMessage() {
            messageBox.classList.remove('show', 'game-over');
            messageText.textContent = '';
            playAgainButton.style.display = 'none';
            if (messageBox.timeoutId) {
                clearTimeout(messageBox.timeoutId);
                messageBox.timeoutId = null;
            }
        }


        // Game Entities
        class PlayerShip {
            constructor() {
                // Player's absolute position in the large world
                this.worldX = getRandomInt(0, WORLD_WIDTH);
                this.worldY = getRandomInt(0, WORLD_HEIGHT);
                // Player is always drawn at the center of the screen
                this.screenX = canvas.width / 2;
                this.screenY = canvas.height / 2;

                this.radius = 15;
                this.angle = -Math.PI / 2; // Pointing upwards (initial orientation)
                this.speedX = 0;
                this.speedY = 0;

                // Player stats, can be upgraded
                this.acceleration = PLAYER_ACCELERATION_BASE;
                this.maxSpeed = PLAYER_MAX_SPEED_BASE;
                this.rotationSpeed = PLAYER_ROTATION_SPEED_BASE;
                this.shotCooldown = SHOT_COOLDOWN_BASE;
                this.weaponDamage = PROJECTILE_DAMAGE_BASE;

                this.credits = 100;
                this.cargo = { 'Copper Ore': 0 }; // Initial cargo
                this.maxCargo = PLAYER_CARGO_CAPACITY_BASE;
                this.currentCargoWeight = 0; // Sum of quantities

                this.maxShield = PLAYER_INITIAL_SHIELD_BASE;
                this.shield = this.maxShield;
                this.shieldRechargeRate = PLAYER_SHIELD_RECHARGE_RATE;
                this.shieldHitTimer = 0; // Timer for shield visual effect
                this.mass = 75000; // Assign mass to player

                this.maxHull = PLAYER_INITIAL_HULL_BASE; // New hull property
                this.hull = this.maxHull; // Current hull strength
            }

            updateCargoWeight() {
                this.currentCargoWeight = Object.values(this.cargo).reduce((sum, qty) => sum + qty, 0);
            }

            addCargo(item, quantity = 1) {
                if (this.currentCargoWeight + quantity <= this.maxCargo) {
                    this.cargo[item] = (this.cargo[item] || 0) + quantity;
                    this.updateCargoWeight();
                    showMessage(`Picked up ${quantity} ${item}!`);
                    return true;
                } else {
                    return false;
                }
            }

            removeCargo(item, quantity = 1) {
                if (this.cargo[item] && this.cargo[item] >= quantity) {
                    this.cargo[item] -= quantity;
                    if (this.cargo[item] === 0) {
                        delete this.cargo[item];
                    }
                    this.updateCargoWeight();
                    return true;
                }
                return false;
            }

            update() {
                // Rotation
                if (keys['ArrowLeft'] || keys['KeyA']) {
                    this.angle -= this.rotationSpeed;
                }
                if (keys['ArrowRight'] || keys['KeyD']) {
                    this.angle += this.rotationSpeed;
                }

                // Acceleration
                if (keys['ArrowUp'] || keys['KeyW']) {
                    this.speedX += Math.cos(this.angle) * this.acceleration;
                    this.speedY += Math.sin(this.angle) * this.acceleration;
                }
                if (keys['ArrowDown'] || keys['KeyS']) {
                    this.speedX -= Math.cos(this.angle) * this.acceleration * 0.5; // Reverse thrust
                    this.speedY -= Math.sin(this.angle) * this.acceleration * 0.5;
                }

                // Limit speed
                const currentSpeed = Math.sqrt(this.speedX * this.speedX + this.speedY * this.speedY);
                if (currentSpeed > this.maxSpeed) {
                    this.speedX = (this.speedX / currentSpeed) * this.maxSpeed;
                    this.speedY = (this.speedY / currentSpeed) * this.maxSpeed;
                }

                // Update player's absolute world position
                this.worldX += this.speedX;
                this.worldY += this.speedY;

                // Wrap player's world position around the world bounds
                if (this.worldX < 0) this.worldX += WORLD_WIDTH;
                if (this.worldX >= WORLD_WIDTH) this.worldX -= WORLD_WIDTH;
                if (this.worldY < 0) this.worldY += WORLD_HEIGHT;
                if (this.worldY >= WORLD_HEIGHT) this.worldY -= WORLD_HEIGHT;

                // Shield recharge
                if (this.shield < this.maxShield) {
                    this.shield = Math.min(this.maxShield, this.shield + this.shieldRechargeRate);
                }
                // Decrease shield hit effect timer
                if (this.shieldHitTimer > 0) {
                    this.shieldHitTimer--;
                }

                // Update UI
                creditsDisplay.textContent = this.credits.toFixed(0);
                cargoDisplay.textContent = this.currentCargoWeight;
                maxCargoDisplay.textContent = this.maxCargo;
                shieldDisplay.textContent = this.shield.toFixed(0); // Update shield UI
                hullDisplay.textContent = this.hull.toFixed(0); // Update hull UI
            }

            draw() {
                ctx.save();
                ctx.translate(this.screenX, this.screenY); // Player always drawn at screen center
                ctx.rotate(this.angle);

                // Draw ship pointing right (positive X) in its local coordinate system
                // Ship body (triangle)
                ctx.beginPath();
                ctx.moveTo(this.radius * 1.5, 0); // Nose (right)
                ctx.lineTo(-this.radius, -this.radius); // Top wing (left-up)
                ctx.lineTo(-this.radius, this.radius); // Bottom wing (left-down)
                ctx.closePath();
                ctx.fillStyle = '#ADD8E6'; // Light blue
                ctx.strokeStyle = '#00FFFF'; // Cyan outline
                ctx.lineWidth = 2;
                ctx.fill();
                ctx.stroke();

                // Thrusters (rectangles at back, adjusted for right-pointing ship)
                ctx.fillStyle = '#FF4500'; // Orange-red
                ctx.fillRect(-this.radius * 0.8, -this.radius * 0.6, this.radius * 0.5, this.radius * 0.4);
                ctx.fillRect(-this.radius * 0.8, this.radius * 0.2, this.radius * 0.5, this.radius * 0.4);
                ctx.restore();

                // Draw shield visual effect if active
                if (this.shieldHitTimer > 0) {
                    ctx.save();
                    ctx.translate(this.screenX, this.screenY);
                    // Calculate opacity based on timer for fading effect
                    const opacity = this.shieldHitTimer / SHIELD_HIT_EFFECT_DURATION;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * 1.5, 0, Math.PI * 2); // Larger circle for shield
                    ctx.strokeStyle = `rgba(0, 200, 255, ${opacity})`; // Blueish shield
                    ctx.lineWidth = 5;
                    ctx.stroke();
                    ctx.restore();
                }
            }

            fire() {
                if (gameFrame - lastShotFrame > this.shotCooldown) {
                    // Projectile starts at player's world position, slightly ahead of the ship's nose
                    const startWorldX = this.worldX + Math.cos(this.angle) * this.radius * 1.5;
                    const startWorldY = this.worldY + Math.sin(this.angle) * this.radius * 1.5;
                    // Pass player's current speed components to the projectile
                    projectiles.push(new Projectile(startWorldX, startWorldY, this.angle, this.weaponDamage, this.speedX, this.speedY));
                    lastShotFrame = gameFrame;
                }
            }
        }

        class Projectile {
            // Projectile constructor now accepts player's speed components
            constructor(worldX, worldY, angle, damage, playerSpeedX, playerSpeedY) {
                this.worldX = worldX;
                this.worldY = worldY;
                this.radius = 3;
                // Add player's current speed to the projectile's initial velocity
                this.speedX = Math.cos(angle) * PROJECTILE_SPEED + playerSpeedX;
                this.speedY = Math.sin(angle) * PROJECTILE_SPEED + playerSpeedY;
                this.lifespan = PROJECTILE_LIFESPAN;
                this.damage = damage; // Store damage
            }

            update() {
                // Update projectile's absolute world position
                this.worldX += this.speedX;
                this.worldY += this.speedY;
                this.lifespan--;

                // Wrap projectile's world position
                if (this.worldX < 0) this.worldX += WORLD_WIDTH;
                if (this.worldX >= WORLD_WIDTH) this.worldX -= WORLD_WIDTH;
                if (this.worldY < 0) this.worldY += WORLD_HEIGHT;
                if (this.worldY >= WORLD_HEIGHT) this.worldY -= WORLD_HEIGHT;
            }

            draw() {
                let relativeWorldX = this.worldX - player.worldX;
                let relativeWorldY = this.worldY - player.worldY;

                // Adjust for world wrapping to find the shortest path
                if (relativeWorldX > WORLD_WIDTH / 2) relativeWorldX -= WORLD_WIDTH;
                if (relativeWorldX < -WORLD_WIDTH / 2) relativeWorldX += WORLD_WIDTH;
                if (relativeWorldY > WORLD_HEIGHT / 2) relativeWorldY -= WORLD_HEIGHT;
                if (relativeWorldY < -WORLD_HEIGHT / 2) relativeWorldY += WORLD_HEIGHT;

                // Calculate screen position relative to player's screen position
                const screenX = player.screenX + relativeWorldX;
                const screenY = player.screenY + relativeWorldY;

                ctx.beginPath();
                ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#FFD700'; // Gold
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#FFD700';
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow
            }
        }

        class Asteroid {
            constructor(worldX, worldY, radius, type = 'copper') {
                this.worldX = worldX;
                this.worldY = worldY;
                this.radius = radius;
                this.speedX = (Math.random() - 0.5) * ASTEROID_SPEED * 2;
                this.speedY = (Math.random() - 0.5) * ASTEROID_SPEED * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.1; // Slower rotation
                this.angle = Math.random() * Math.PI * 2;
                this.type = type; // 'copper', 'iron', 'ice'

                switch (this.type) {
                    case 'iron':
                        this.health = IRON_ASTEROID_HEALTH;
                        this.itemType = 'Iron Ore';
                        this.fillStyle = '#A9A9A9'; // DarkGray
                        this.strokeStyle = '#696969'; // DimGray
                        break;
                    case 'ice':
                        this.health = ICE_ASTEROID_HEALTH;
                        this.itemType = 'Water Ice';
                        this.fillStyle = '#ADD8E6'; // LightBlue
                        this.strokeStyle = '#B0E0E6'; // PowderBlue
                        break;
                    case 'copper':
                    default:
                        this.health = COPPER_ASTEROID_HEALTH;
                        this.itemType = 'Copper Ore';
                        this.fillStyle = '#8B4513'; // SaddleBrown
                        this.strokeStyle = '#A0522D'; // Sienna
                        break;
                }
                this.maxHealth = this.health; // Store max health for reference (though not used for drawing now)
                this.mass = Math.PI * this.radius * this.radius * this.radius; // Mass proportional to volume (radius cubed)

                // Generate asteroid shape points once in the constructor
                this.shapePoints = [];
                const numPoints = getRandomInt(5, 9);
                for (let i = 0; i < numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI * 2;
                    const variation = (Math.random() * 0.3 + 0.7); // 70-100% of radius
                    const currentRadius = this.radius * variation;
                    this.shapePoints.push({
                        x: Math.cos(angle) * currentRadius,
                        y: Math.sin(angle) * currentRadius
                    });
                }
            }

            update() {
                // Update asteroid's absolute world position
                this.worldX += this.speedX;
                this.worldY += this.speedY;
                this.angle += this.rotationSpeed;

                // Wrap asteroid's world position
                if (this.worldX < 0) this.worldX += WORLD_WIDTH;
                if (this.worldX >= WORLD_WIDTH) this.worldX -= WORLD_WIDTH;
                if (this.worldY < 0) this.worldY += WORLD_HEIGHT;
                if (this.worldY >= WORLD_HEIGHT) this.worldY -= WORLD_HEIGHT;
            }

            draw() {
                let relativeWorldX = this.worldX - player.worldX;
                let relativeWorldY = this.worldY - player.worldY;

                // Adjust for world wrapping to find the shortest path
                if (relativeWorldX > WORLD_WIDTH / 2) relativeWorldX -= WORLD_WIDTH;
                if (relativeWorldX < -WORLD_WIDTH / 2) relativeWorldX += WORLD_WIDTH;
                if (relativeWorldY > WORLD_HEIGHT / 2) relativeWorldY -= WORLD_HEIGHT;
                if (relativeWorldY < -WORLD_HEIGHT / 2) relativeWorldY += WORLD_HEIGHT;

                // Calculate screen position relative to player's screen position
                const screenX = player.screenX + relativeWorldX;
                const screenY = player.screenY + relativeWorldY;

                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.angle);

                // Draw the asteroid shape using pre-generated points
                ctx.beginPath();
                this.shapePoints.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.closePath();
                ctx.fillStyle = this.fillStyle; // Use asteroid's specific fill style
                ctx.strokeStyle = this.strokeStyle; // Use asteroid's specific stroke style
                ctx.lineWidth = 2;
                ctx.fill();
                ctx.stroke();

                ctx.restore();
            }
        }

        class Ore {
            // Ore constructor now accepts speed components
            constructor(worldX, worldY, itemType, speedX = 0, speedY = 0) {
                this.worldX = worldX;
                this.worldY = worldY;
                this.radius = ORE_SIZE / 2;
                this.lifespan = ORE_LIFESPAN;
                this.itemType = itemType; // Set item type based on asteroid
                this.speedX = speedX; // Inherit speed from asteroid
                this.speedY = speedY; // Inherit speed from asteroid
            }

            update() {
                // Update ore's absolute world position based on its inherited speed
                this.worldX += this.speedX;
                this.worldY += this.speedY;
                this.lifespan--;

                // Wrap ore's world position
                if (this.worldX < 0) this.worldX += WORLD_WIDTH;
                if (this.worldX >= WORLD_WIDTH) this.worldX -= WORLD_WIDTH;
                if (this.worldY < 0) this.worldY += WORLD_HEIGHT;
                if (this.worldY >= WORLD_HEIGHT) this.worldY -= WORLD_HEIGHT;
            }

            draw() {
                let relativeWorldX = this.worldX - player.worldX;
                let relativeWorldY = this.worldY - player.worldY;

                // Adjust for world wrapping to find the shortest path
                if (relativeWorldX > WORLD_WIDTH / 2) relativeWorldX -= WORLD_WIDTH;
                if (relativeWorldX < -WORLD_WIDTH / 2) relativeWorldX += WORLD_WIDTH;
                if (relativeWorldY > WORLD_HEIGHT / 2) relativeWorldY -= WORLD_HEIGHT;
                if (relativeWorldY < -WORLD_HEIGHT / 2) relativeWorldY += WORLD_HEIGHT;

                // Calculate screen position relative to player's screen position
                const screenX = player.screenX + relativeWorldX;
                const screenY = player.screenY + relativeWorldY;

                ctx.beginPath();
                ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                // Use a consistent color for all ores for simplicity, as type is shown in UI
                ctx.fillStyle = '#00FF00'; // Green for ore
                ctx.shadowBlur = 8;
                ctx.shadowColor = '#00FF00';
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow
            }
        }

        class Planet {
            constructor(worldX, worldY, name) {
                this.worldX = worldX;
                this.worldY = worldY;
                this.radius = PLANET_RADIUS;
                this.name = name;
                this.inventory = this.generateInventory();
            }

            generateInventory() {
                const inv = {};
                // Each planet has a random subset of items
                const allItemTypes = Object.keys(ITEMS);
                const numItemsOnPlanet = getRandomInt(3, 7); // Planets trade 3 to 7 types of items

                // Ensure 'Copper Ore' is always available for mining, if it's an asteroid type
                if (allItemTypes.includes('Copper Ore')) {
                    const copperInitialStock = getRandomInt(5, 15);
                    const copperBuyPrice = getRandomInt(ITEMS['Copper Ore'].basePrice * 0.8, ITEMS['Copper Ore'].basePrice * 1.2);
                    inv['Copper Ore'] = {
                        buyPrice: copperBuyPrice,
                        sellPrice: Math.floor(copperBuyPrice * PLANET_SELL_BACK_FACTOR),
                        stock: copperInitialStock,
                        naturalStock: copperInitialStock
                    };
                }

                // Add other random items
                const availableItems = allItemTypes.filter(item => !inv[item]); // Exclude already added items
                for (let i = 0; i < numItemsOnPlanet; i++) {
                    if (availableItems.length === 0) break; // No more unique items to add

                    const randomIndex = getRandomInt(0, availableItems.length - 1);
                    const item = availableItems[randomIndex];
                    availableItems.splice(randomIndex, 1); // Remove item to avoid duplicates

                    const buyPriceForPlayer = getRandomInt(ITEMS[item].basePrice * 0.7, ITEMS[item].basePrice * 1.3);
                    const initialStock = getRandomInt(2, 100);
                    inv[item] = {
                        buyPrice: buyPriceForPlayer,
                        sellPrice: Math.floor(buyPriceForPlayer * PLANET_SELL_BACK_FACTOR),
                        stock: initialStock,
                        naturalStock: initialStock
                    };
                }

                // Ensure Iron Ore and Water Ice are also available for sale on at least one planet
                const asteroidOreTypes = ['Iron Ore', 'Water Ice'];
                asteroidOreTypes.forEach(oreType => {
                    if (!inv[oreType]) {
                        const basePrice = ITEMS[oreType].basePrice;
                        const buyPriceForPlayer = getRandomInt(basePrice * 0.7, basePrice * 1.3);
                        const initialStock = getRandomInt(2, 100);
                        inv[oreType] = {
                            buyPrice: buyPriceForPlayer,
                            sellPrice: Math.floor(buyPriceForPlayer * PLANET_SELL_BACK_FACTOR),
                            stock: initialStock,
                            naturalStock: initialStock
                        };
                    }
                });

                return inv;
            }

            update() {
                // Planets' absolute world position doesn't change on their own, only relative to player's movement
                // Wrap planet's world position
                if (this.worldX < 0) this.worldX += WORLD_WIDTH;
                if (this.worldX >= WORLD_WIDTH) this.worldX -= WORLD_WIDTH;
                if (this.worldY < 0) this.worldY += WORLD_HEIGHT;
                if (this.worldY >= WORLD_HEIGHT) this.worldY -= WORLD_HEIGHT;

                // Regenerate stock towards natural amount
                if (gameFrame % PLANET_STOCK_REGENERATION_INTERVAL === 0) {
                    for (const itemType in this.inventory) {
                        const itemData = this.inventory[itemType];
                        const naturalStock = itemData.naturalStock;
                        let currentStock = itemData.stock;

                        if (currentStock < naturalStock) {
                            currentStock = Math.min(naturalStock, currentStock + PLANET_STOCK_REGENERATION_RATE);
                        } else if (currentStock > naturalStock) {
                            currentStock = Math.max(naturalStock, currentStock - PLANET_STOCK_REGENERATION_RATE);
                        }
                        itemData.stock = currentStock; // Update the actual stock
                    }
                }
            }

            draw() {
                let relativeWorldX = this.worldX - player.worldX;
                let relativeWorldY = this.worldY - player.worldY;

                // Adjust for world wrapping to find the shortest path
                if (relativeWorldX > WORLD_WIDTH / 2) relativeWorldX -= WORLD_WIDTH;
                if (relativeWorldX < -WORLD_WIDTH / 2) relativeWorldX += WORLD_WIDTH;
                if (relativeWorldY > WORLD_HEIGHT / 2) relativeWorldY -= WORLD_HEIGHT;
                if (relativeWorldY < -WORLD_HEIGHT / 2) relativeWorldY += WORLD_HEIGHT;

                // Calculate screen position relative to player's screen position
                const screenX = player.screenX + relativeWorldX;
                const screenY = player.screenY + relativeWorldY;

                ctx.beginPath();
                ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#4169E1'; // RoyalBlue
                ctx.strokeStyle = '#1E90FF'; // DodgerBlue
                ctx.lineWidth = 3;
                ctx.fill();
                ctx.stroke();

                // Draw a small ring or atmosphere
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.radius + 5, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Planet name text
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '12px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, screenX, screenY + this.radius + 15);
            }
        }

        class SpaceStation {
            constructor(worldX, worldY, name) {
                this.worldX = worldX;
                this.worldY = worldY;
                this.radius = SPACE_STATION_RADIUS;
                this.name = name;
            }

            update() {
                // Space Station's absolute world position doesn't change on its own
                // Wrap station's world position
                if (this.worldX < 0) this.worldX += WORLD_WIDTH;
                if (this.worldX >= WORLD_WIDTH) this.worldX -= WORLD_WIDTH;
                if (this.worldY < 0) this.worldY += WORLD_HEIGHT;
                if (this.worldY >= WORLD_HEIGHT) this.worldY -= WORLD_HEIGHT;
            }

            draw() {
                let relativeWorldX = this.worldX - player.worldX;
                let relativeWorldY = this.worldY - player.worldY;

                // Adjust for world wrapping to find the shortest path
                if (relativeWorldX > WORLD_WIDTH / 2) relativeWorldX -= WORLD_WIDTH;
                if (relativeWorldX < -WORLD_WIDTH / 2) relativeWorldX += WORLD_WIDTH;
                if (relativeWorldY > WORLD_HEIGHT / 2) relativeWorldY -= WORLD_HEIGHT;
                if (relativeWorldY < -WORLD_HEIGHT / 2) relativeWorldY += WORLD_HEIGHT;

                // Calculate screen position relative to player's screen position
                const screenX = player.screenX + relativeWorldX;
                const screenY = player.screenY + relativeWorldY;

                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(Math.PI / 4); // Rotate for a diamond shape

                // Draw a simple space station (e.g., a square with extensions)
                ctx.fillStyle = '#696969'; // DimGray
                ctx.strokeStyle = '#C0C0C0'; // Silver
                ctx.lineWidth = 3;

                // Main body (square)
                ctx.fillRect(-this.radius, -this.radius, this.radius * 2, this.radius * 2);
                ctx.strokeRect(-this.radius, -this.radius, this.radius * 2, this.radius * 2);

                // Extensions (rectangles)
                ctx.fillRect(-this.radius * 0.5, -this.radius * 1.5, this.radius, this.radius * 0.5); // Top
                ctx.fillRect(-this.radius * 0.5, this.radius * 1, this.radius, this.radius * 0.5); // Bottom
                ctx.fillRect(-this.radius * 1.5, -this.radius * 0.5, this.radius * 0.5, this.radius); // Left
                ctx.fillRect(this.radius * 1, -this.radius * 0.5, this.radius * 0.5, this.radius); // Right

                ctx.strokeRect(-this.radius * 0.5, -this.radius * 1.5, this.radius, this.radius * 0.5);
                ctx.strokeRect(-this.radius * 0.5, this.radius * 1, this.radius, this.radius * 0.5);
                ctx.strokeRect(-this.radius * 1.5, -this.radius * 0.5, this.radius * 0.5, this.radius);
                ctx.strokeRect(this.radius * 1, -this.radius * 0.5, this.radius * 0.5, this.radius);


                ctx.restore();

                // Station name text
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '14px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, screenX, screenY + this.radius + 20);
            }
        }


        // Game Initialization
        function initGame() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            // Set world dimensions based on canvas size
            WORLD_WIDTH = canvas.width * WORLD_SCALE_FACTOR;
            WORLD_HEIGHT = canvas.height * WORLD_SCALE_FACTOR;

            // Initialize radar canvas dimensions
            radarCanvas.width = radarCanvas.offsetWidth;
            radarCanvas.height = radarCanvas.offsetHeight;
            updateRadarScale(); // Calculate initial radar scale

            player = new PlayerShip();
            player.updateCargoWeight(); // Set initial cargo weight

            // Spawn initial asteroids randomly across the large world
            for (let i = 0; i < ASTEROID_MAX_COUNT / 2; i++) {
                spawnAsteroid();
            }

            // Spawn initial planets randomly across the large world
            const planetNames = ['Xylos', 'Kryll', 'Aethel', 'Zephyr', 'Nova Prime'];
            for (let i = 0; i < PLANET_MAX_COUNT; i++) {
                spawnPlanet(planetNames[i]);
            }

            // Spawn space stations
            const stationNames = ['Alpha Shipyard', 'Orion Station'];
            for (let i = 0; i < SPACE_STATION_MAX_COUNT; i++) {
                spawnSpaceStation(stationNames[i]);
            }

            // Generate static starfield
            stars = [];
            for (let i = 0; i < NUM_STARS; i++) {
                const x = getRandomInt(0, WORLD_WIDTH);
                const y = getRandomInt(0, WORLD_HEIGHT);
                const radius = Math.random() * 1.5 + 0.5; // Stars between 0.5 and 2 pixels
                const colorChance = Math.random();
                let color;
                if (colorChance < 0.8) { // 80% white
                    color = '#FFFFFF';
                } else if (colorChance < 0.9) { // 10% light red
                    color = '#FFCCCC';
                } else { // 10% light blue
                    color = '#CCEEFF';
                }
                // Reduced parallax depth to make stars feel more distant
                const parallaxDepth = Math.random() * 0.3 + 0.05; // Depth from 0.05 (further, less movement) to 0.35 (closer, more movement)
                stars.push({ worldX: x, worldY: y, radius: radius, color: color, parallaxDepth: parallaxDepth });
            }

            // Handle canvas resize
            window.addEventListener('resize', () => {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                // Update screen position for player if canvas size changes
                player.screenX = canvas.width / 2;
                player.screenY = canvas.height / 2;
                // Re-calculate world dimensions based on new canvas size
                WORLD_WIDTH = canvas.width * WORLD_SCALE_FACTOR;
                WORLD_HEIGHT = canvas.height * WORLD_SCALE_FACTOR;

                // Re-initialize radar canvas dimensions and scale
                radarCanvas.width = radarCanvas.offsetWidth;
                radarCanvas.height = radarCanvas.offsetHeight;
                updateRadarScale();
            });
        }

        function updateRadarScale() {
            // Calculate scale factors for radar based on world size and radar canvas size
            RADAR_SCALE_FACTOR_X = radarCanvas.width / WORLD_WIDTH;
            RADAR_SCALE_FACTOR_Y = radarCanvas.height / WORLD_HEIGHT;
        }

        function spawnAsteroid() {
            if (asteroids.length >= ASTEROID_MAX_COUNT) return;

            // Define asteroid types to randomly choose from
            const asteroidTypes = ['copper', 'iron', 'ice'];
            const randomType = asteroidTypes[getRandomInt(0, asteroidTypes.length - 1)];
            const radius = getRandomInt(ASTEROID_SIZE_MIN, ASTEROID_SIZE_MAX);

            // Calculate a minimum spawn distance that ensures the asteroid is off-screen
            // This should be at least half the diagonal of the canvas plus some buffer
            const MIN_SPAWN_DISTANCE_FROM_PLAYER = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height) / 2 + ASTEROID_SIZE_MAX * 2;

            let x, y, dist;
            let attempts = 0;
            const MAX_ATTEMPTS = 100; // Prevent infinite loops in case of very small world/large exclusion zone

            do {
                x = getRandomInt(0, WORLD_WIDTH);
                y = getRandomInt(0, WORLD_HEIGHT);
                dist = getDistance(player.worldX, player.worldY, x, y);
                attempts++;
            } while (dist < MIN_SPAWN_DISTANCE_FROM_PLAYER && attempts < MAX_ATTEMPTS);

            // If after max attempts, we still can't find a spot, just spawn it at the edge of the exclusion zone
            if (attempts >= MAX_ATTEMPTS) {
                // Fallback: spawn at a fixed distance from player, ensuring it's outside the immediate view
                const angle = Math.random() * Math.PI * 2;
                x = player.worldX + Math.cos(angle) * MIN_SPAWN_DISTANCE_FROM_PLAYER;
                y = player.worldY + Math.sin(angle) * MIN_SPAWN_DISTANCE_FROM_PLAYER;

                // Ensure it wraps correctly if it goes beyond world bounds
                if (x < 0) x += WORLD_WIDTH;
                if (x >= WORLD_WIDTH) x -= WORLD_WIDTH;
                if (y < 0) y += WORLD_HEIGHT;
                if (y >= WORLD_HEIGHT) y -= WORLD_HEIGHT;
            }

            asteroids.push(new Asteroid(x, y, radius, randomType));
        }

        function spawnPlanet(name) {
            // Spawn planet at a random position within the large world
            const x = getRandomInt(0, WORLD_WIDTH);
            const y = getRandomInt(0, WORLD_HEIGHT);
            planets.push(new Planet(x, y, name));
        }

        function spawnSpaceStation(name) {
            // Spawn space station at a random position within the large world
            const x = getRandomInt(0, WORLD_WIDTH);
            const y = getRandomInt(0, WORLD_HEIGHT);
            spaceStations.push(new SpaceStation(x, y, name));
        }

        // Function to draw the radar map
        function drawRadar() {
            radarCtx.clearRect(0, 0, radarCanvas.width, radarCanvas.height);
            radarCtx.fillStyle = 'rgba(0, 0, 0, 0.7)'; // Background for radar
            radarCtx.fillRect(0, 0, radarCanvas.width, radarCanvas.height);

            // Draw player dot in the center of the radar
            radarCtx.beginPath();
            radarCtx.arc(radarCanvas.width / 2, radarCanvas.height / 2, RADAR_DOT_SIZE, 0, Math.PI * 2);
            radarCtx.fillStyle = '#00FFFF'; // Cyan for player
            radarCtx.fill();

            // Draw planets on radar
            planets.forEach(planet => {
                let relativeWorldX = planet.worldX - player.worldX;
                let relativeWorldY = planet.worldY - player.worldY;

                // Handle world wrapping for radar display (shortest distance)
                if (relativeWorldX > WORLD_WIDTH / 2) relativeWorldX -= WORLD_WIDTH;
                if (relativeWorldX < -WORLD_WIDTH / 2) relativeWorldX += WORLD_WIDTH;
                if (relativeWorldY > WORLD_HEIGHT / 2) relativeWorldY -= WORLD_HEIGHT;
                if (relativeWorldY < -WORLD_HEIGHT / 2) relativeWorldY += WORLD_HEIGHT;

                const radarX = radarCanvas.width / 2 + relativeWorldX * RADAR_SCALE_FACTOR_X;
                const radarY = radarCanvas.height / 2 + relativeWorldY * RADAR_SCALE_FACTOR_Y;

                // Only draw if within radar bounds
                if (radarX >= 0 && radarX <= radarCanvas.width && radarY >= 0 && radarY <= radarCanvas.height) {
                    radarCtx.beginPath();
                    radarCtx.arc(radarX, radarY, RADAR_DOT_SIZE, 0, Math.PI * 2);
                    radarCtx.fillStyle = '#4169E1'; // RoyalBlue for planets
                    radarCtx.fill();
                }
            });

            // Draw space stations on radar
            spaceStations.forEach(station => {
                let relativeWorldX = station.worldX - player.worldX;
                let relativeWorldY = station.worldY - player.worldY;

                // Handle world wrapping for radar display (shortest distance)
                if (relativeWorldX > WORLD_WIDTH / 2) relativeWorldX -= WORLD_WIDTH;
                if (relativeWorldX < -WORLD_WIDTH / 2) relativeWorldX += WORLD_WIDTH;
                if (relativeWorldY > WORLD_HEIGHT / 2) relativeWorldY -= WORLD_HEIGHT;
                if (relativeWorldY < -WORLD_HEIGHT / 2) relativeWorldY += WORLD_HEIGHT;

                const radarX = radarCanvas.width / 2 + relativeWorldX * RADAR_SCALE_FACTOR_X;
                const radarY = radarCanvas.height / 2 + relativeWorldY * RADAR_SCALE_FACTOR_Y;

                // Only draw if within radar bounds
                if (radarX >= 0 && radarX <= radarCanvas.width && radarY >= 0 && radarY <= radarCanvas.height) {
                    radarCtx.beginPath();
                    radarCtx.rect(radarX - RADAR_DOT_SIZE, radarY - RADAR_DOT_SIZE, RADAR_DOT_SIZE * 2, RADAR_DOT_SIZE * 2); // Square for station
                    radarCtx.fillStyle = '#FF00FF'; // Magenta for space stations
                    radarCtx.fill();
                }
            });

            // Draw asteroids on radar
            asteroids.forEach(asteroid => {
                let relativeWorldX = asteroid.worldX - player.worldX;
                let relativeWorldY = asteroid.worldY - player.worldY;

                // Handle world wrapping for radar display (shortest distance)
                if (relativeWorldX > WORLD_WIDTH / 2) relativeWorldX -= WORLD_WIDTH;
                if (relativeWorldX < -WORLD_WIDTH / 2) relativeWorldX += WORLD_WIDTH;
                if (relativeWorldY > WORLD_HEIGHT / 2) relativeWorldY -= WORLD_HEIGHT;
                if (relativeWorldY < -WORLD_HEIGHT / 2) relativeWorldY += WORLD_HEIGHT;

                const radarX = radarCanvas.width / 2 + relativeWorldX * RADAR_SCALE_FACTOR_X;
                const radarY = radarCanvas.height / 2 + relativeWorldY * RADAR_SCALE_FACTOR_Y;

                // Only draw if within radar bounds
                if (radarX >= 0 && radarX <= radarCanvas.width && radarY >= 0 && radarY <= radarCanvas.height) {
                    radarCtx.beginPath();
                    radarCtx.arc(radarX, radarY, RADAR_DOT_SIZE * 0.7, 0, Math.PI * 2); // Smaller dot for asteroids
                    // Radar dot color for asteroids remains consistent for simplicity
                    radarCtx.fillStyle = '#8B4513'; // SaddleBrown for asteroids
                    radarCtx.fill();
                }
            });
        }

        // Function to resolve elastic collision between two circular objects
        function resolveCollision(obj1, obj2) {
            // Vector from obj1 to obj2
            const dx = obj2.worldX - obj1.worldX;
            const dy = obj2.worldY - obj1.worldY;
            const distance = getDistance(obj1.worldX, obj1.worldY, obj2.worldX, obj2.worldY); // Recalculate distance to be accurate

            // If objects are not overlapping or are perfectly aligned, return
            if (distance === 0 || distance > obj1.radius + obj2.radius) {
                return;
            }

            // Normalize collision normal vector
            const nx = dx / distance;
            const ny = dy / distance;

            // Relative velocity vector
            const rvx = obj1.speedX - obj2.speedX;
            const rvy = obj1.speedY - obj2.speedY;

            // Velocity along the normal
            const velAlongNormal = rvx * nx + rvy * ny;

            // Do not resolve if velocities are separating
            if (velAlongNormal > 0) return;

            // Coefficient of restitution (e.g., 0.8 for a slightly bouncy collision)
            const e = 0.95; // Increased for more noticeable bounce

            // Calculate impulse scalar
            const impulseScalar = -(1 + e) * velAlongNormal / (1 / obj1.mass + 1 / obj2.mass);

            // Apply impulse
            obj1.speedX += impulseScalar * nx / obj1.mass;
            obj1.speedY += impulseScalar * ny / obj1.mass;
            obj2.speedX -= impulseScalar * nx / obj2.mass;
            obj2.speedY -= impulseScalar * ny / obj2.mass;

            // Separate objects slightly to prevent sticking
            const penetrationDepth = (obj1.radius + obj2.radius) - distance;
            if (penetrationDepth > 0) {
                const totalInverseMass = 1 / obj1.mass + 1 / obj2.mass;
                const separationFactor = penetrationDepth / totalInverseMass;

                obj1.worldX -= separationFactor * nx / obj1.mass;
                obj1.worldY -= separationFactor * ny / obj1.mass;
                obj2.worldX += separationFactor * nx / obj2.mass;
                obj2.worldY += separationFactor * ny / obj2.mass;
            }
        }

        // Game Loop
        function animate() {
            // Request the next frame at the beginning of the function
            animationFrameId = requestAnimationFrame(animate);

            // Check if game is paused or over
            if (isGamePaused || isGameOver) {
                return; // Stop game logic updates for this frame
            }

            // If we reach here, the game is running, so hide pause message.
            pauseMessage.style.display = 'none';

            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear main canvas

            // Draw static starfield with parallax
            stars.forEach(star => {
                let relativeWorldX = star.worldX - player.worldX;
                let relativeWorldY = star.worldY - player.worldY;

                // Adjust for world wrapping to find the shortest path for parallax
                if (relativeWorldX > WORLD_WIDTH / 2) relativeWorldX -= WORLD_WIDTH;
                if (relativeWorldX < -WORLD_WIDTH / 2) relativeWorldX += WORLD_WIDTH;
                if (relativeWorldY > WORLD_HEIGHT / 2) relativeWorldY -= WORLD_HEIGHT;
                if (relativeWorldY < -WORLD_HEIGHT / 2) relativeWorldY += WORLD_HEIGHT;

                // Apply parallax effect
                const parallaxScreenX = player.screenX + relativeWorldX * star.parallaxDepth;
                const parallaxScreenY = player.screenY + relativeWorldY * star.parallaxDepth;

                // Only draw if within canvas bounds
                if (parallaxScreenX + star.radius > 0 && parallaxScreenX - star.radius < canvas.width &&
                    parallaxScreenY + star.radius > 0 && parallaxScreenY - star.radius < canvas.height) {
                    ctx.beginPath();
                    ctx.arc(parallaxScreenX, parallaxScreenY, star.radius, 0, Math.PI * 2);
                    ctx.fillStyle = star.color;
                    ctx.fill();
                }
            });


            // Update player
            player.update();

            // Handle continuous firing if spacebar is held
            if (keys['Space']) {
                player.fire();
            }

            // Spawn asteroids
            if (gameFrame % ASTEROID_SPAWN_INTERVAL === 0 && asteroids.length < ASTEROID_MAX_COUNT) {
                spawnAsteroid();
            }

            let newClosestDockable = null;
            let minDockingDistance = Infinity;

            // Update and draw planets
            for (let i = planets.length - 1; i >= 0; i--) {
                const planet = planets[i];
                planet.update(); // Update planet's world position (wraps if needed)
                planet.draw();

                // Check proximity to planet using world coordinates
                const distToPlanet = getDistance(player.worldX, player.worldY, planet.worldX, planet.worldY);
                if (distToPlanet < PLANET_PROXIMITY_RADIUS) {
                    if (distToPlanet < minDockingDistance) {
                        minDockingDistance = distToPlanet;
                        newClosestDockable = { type: 'planet', entity: planet };
                    }
                }
            }

            // Update and draw space stations
            for (let i = spaceStations.length - 1; i >= 0; i--) {
                const station = spaceStations[i];
                station.update();
                station.draw();

                // Check proximity to space station
                const distToStation = getDistance(player.worldX, player.worldY, station.worldX, station.worldY);
                if (distToStation < SPACE_STATION_PROXIMITY_RADIUS) {
                    if (distToStation < minDockingDistance) {
                        minDockingDistance = distToStation;
                        newClosestDockable = { type: 'station', entity: station };
                    }
                }
            }

            // Update current dockable target and messages based on newClosestDockable
            if (newClosestDockable) {
                if (newClosestDockable.type === 'planet') {
                    // Only show message if we are approaching a *new* planet or the current target changes
                    if (dockableTargetCandidate?.entity !== newClosestDockable.entity || dockableTargetCandidate?.type !== 'planet') {
                        showMessage(`Approaching ${newClosestDockable.entity.name}... Press 'E' to dock.`);
                    }
                    currentPlanet = newClosestDockable.entity;
                    currentSpaceStation = null; // Ensure only one is active
                    dockableTargetCandidate = newClosestDockable; // Store the candidate
                } else if (newClosestDockable.type === 'station') {
                    // Only show message if we are approaching a *new* station or the current target changes
                    if (dockableTargetCandidate?.entity !== newClosestDockable.entity || dockableTargetCandidate?.type !== 'station') {
                        showMessage(`Approaching ${newClosestDockable.entity.name}... Press 'E' to dock.`);
                    }
                    currentSpaceStation = newClosestDockable.entity;
                    currentPlanet = null; // Ensure only one is active
                    dockableTargetCandidate = newClosestDockable; // Store the candidate
                }
            } else {
                // If no dockable entity is in range, clear both and show "Leaving docking range" if applicable
                if (dockableTargetCandidate) { // Only show "Leaving docking range" if we were previously near something
                    showMessage("Leaving docking range.");
                }
                currentPlanet = null;
                currentSpaceStation = null;
                dockableTargetCandidate = null; // Clear the candidate
            }


            // Update and draw projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.update(); // Update projectile's world position
                p.draw();

                // Remove old projectiles
                if (p.lifespan <= 0) {
                    projectiles.splice(i, 1);
                    continue;
                }

                // Check for projectile-asteroid collisions using world coordinates
                for (let j = asteroids.length - 1; j >= 0; j--) {
                    const a = asteroids[j];
                    const dist = getDistance(p.worldX, p.worldY, a.worldX, a.worldY);
                    if (dist < p.radius + a.radius) {
                        // Collision!
                        a.health -= p.damage; // Decrement asteroid health by projectile damage

                        // Calculate force applied based on projectile speed and asteroid mass
                        const impactSpeedX = p.speedX / a.mass * p.damage; // Use projectile damage for force
                        const impactSpeedY = p.speedY / a.mass * p.damage;

                        a.speedX += impactSpeedX;
                        a.speedY += impactSpeedY;

                        projectiles.splice(i, 1); // Remove projectile

                        if (a.health <= 0) {
                            asteroids.splice(j, 1); // Remove asteroid if health is zero

                            // Check if asteroid should split or drop ore
                            if (a.radius > ASTEROID_MIN_SPLIT_RADIUS && a.radius * SPLIT_ASTEROID_RADIUS_FACTOR >= ASTEROID_SIZE_MIN) {
                                // Store parent asteroid's momentum
                                const parentMomentumX = a.mass * a.speedX;
                                const parentMomentumY = a.mass * a.speedY;

                                let totalChildMomentumX = 0;
                                let totalChildMomentumY = 0;
                                let totalChildMass = 0;
                                const newAsteroids = [];

                                showMessage(`${a.type} asteroid split!`);
                                for (let k = 0; k < NUM_SPLIT_ASTEROIDS; k++) {
                                    const newRadius = a.radius * SPLIT_ASTEROID_RADIUS_FACTOR;
                                    const newX = a.worldX + (Math.random() - 0.5) * newRadius * 2;
                                    const newY = a.worldY + (Math.random() - 0.5) * newRadius * 2;
                                    const newAsteroid = new Asteroid(newX, newY, newRadius, a.type);

                                    // Give new asteroids some initial random velocity relative to parent's speed
                                    newAsteroid.speedX = a.speedX + (Math.random() - 0.5) * ASTEROID_SPEED * SPLIT_ASTEROID_SPEED_FACTOR;
                                    newAsteroid.speedY = a.speedY + (Math.random() - 0.5) * ASTEROID_SPEED * SPLIT_ASTEROID_SPEED_FACTOR;

                                    newAsteroids.push(newAsteroid);
                                    totalChildMomentumX += newAsteroid.mass * newAsteroid.speedX;
                                    totalChildMomentumY += newAsteroid.mass * newAsteroid.speedY;
                                    totalChildMass += newAsteroid.mass;
                                }

                                // Calculate momentum difference and distribute as velocity correction
                                const deltaMomentumX = parentMomentumX - totalChildMomentumX;
                                const deltaMomentumY = parentMomentumY - totalChildMomentumY;

                                // Avoid division by zero if for some reason totalChildMass is 0 (shouldn't happen with positive radii)
                                if (totalChildMass > 0) {
                                    const correctionSpeedX = deltaMomentumX / totalChildMass;
                                    const correctionSpeedY = deltaMomentumY / totalChildMass;

                                    newAsteroids.forEach(child => {
                                        child.speedX += correctionSpeedX;
                                        child.speedY += correctionSpeedY;
                                    });
                                }

                                // Add the new asteroids to the main asteroids array
                                asteroids.push(...newAsteroids);

                            } else {
                                // Drop ore, inheriting asteroid's speed
                                ores.push(new Ore(a.worldX, a.worldY, a.itemType, a.speedX, a.speedY));
                                showMessage(`${a.type} asteroid destroyed!`);
                            }
                        } else {
                            showMessage(`${a.type} asteroid hit!`);
                        }
                        break; // Exit inner loop as projectile is gone
                    }
                }
            }

            // Update and draw asteroids
            for (let i = asteroids.length - 1; i >= 0; i--) {
                const a = asteroids[i];
                a.update(); // Update asteroid's world position
                a.draw();

                // Check for asteroid-player collisions
                const distToPlayer = getDistance(player.worldX, player.worldY, a.worldX, a.worldY);
                if (distToPlayer < player.radius + a.radius) {
                    // Collision with player
                    // Calculate kinetic energy of asteroid for impact
                    const asteroidSpeedSq = a.speedX * a.speedX + a.speedY * a.speedY;
                    const collisionEnergy = 0.5 * a.mass * asteroidSpeedSq;
                    const damageToApply = collisionEnergy * ASTEROID_COLLISION_ENERGY_FACTOR;

                    if (player.shield > 0) {
                        const shieldAbsorbed = Math.min(player.shield, damageToApply);
                        player.shield -= shieldAbsorbed;
                        let hullDamage = damageToApply - shieldAbsorbed;

                        if (hullDamage > 0) {
                            player.hull -= hullDamage;
                            player.hull = Math.max(0, player.hull);
                            showMessage(`Shield breached! Hull hit! Hull: ${player.hull.toFixed(0)}`);
                        } else {
                            showMessage(`Shield hit! Shield: ${player.shield.toFixed(0)}`);
                        }
                        player.shieldHitTimer = SHIELD_HIT_EFFECT_DURATION; // Activate visual effect

                        // Apply equal damage to asteroid
                        a.health -= damageToApply; // Apply full damage to asteroid
                    } else {
                        // No shield, apply damage directly to hull
                        player.hull -= damageToApply;
                        player.hull = Math.max(0, player.hull);
                        showMessage(`Direct hit! Hull: ${player.hull.toFixed(0)}`);

                        // Apply equal damage to asteroid
                        a.health -= damageToApply; // Apply full damage to asteroid
                    }

                    // Resolve elastic collision (bounce)
                    resolveCollision(player, a);

                    if (a.health <= 0) {
                        asteroids.splice(i, 1); // Remove asteroid if health is zero

                        // Check if asteroid should split or drop ore (SAME LOGIC AS PROJECTILE HIT)
                        if (a.radius > ASTEROID_MIN_SPLIT_RADIUS && a.radius * SPLIT_ASTEROID_RADIUS_FACTOR >= ASTEROID_SIZE_MIN) {
                            const parentMomentumX = a.mass * a.speedX;
                            const parentMomentumY = a.mass * a.speedY;

                            let totalChildMomentumX = 0;
                            let totalChildMomentumY = 0;
                            let totalChildMass = 0;
                            const newAsteroids = [];

                            showMessage(`${a.type} asteroid split!`);
                            for (let k = 0; k < NUM_SPLIT_ASTEROIDS; k++) {
                                const newRadius = a.radius * SPLIT_ASTEROID_RADIUS_FACTOR;
                                const newX = a.worldX + (Math.random() - 0.5) * newRadius * 2;
                                const newY = a.worldY + (Math.random() - 0.5) * newRadius * 2;
                                const newAsteroid = new Asteroid(newX, newY, newRadius, a.type);

                                newAsteroid.speedX = a.speedX + (Math.random() - 0.5) * ASTEROID_SPEED * SPLIT_ASTEROID_SPEED_FACTOR;
                                newAsteroid.speedY = a.speedY + (Math.random() - 0.5) * ASTEROID_SPEED * SPLIT_ASTEROID_SPEED_FACTOR;

                                newAsteroids.push(newAsteroid);
                                totalChildMomentumX += newAsteroid.mass * newAsteroid.speedX;
                                totalChildMomentumY += newAsteroid.mass * newAsteroid.speedY;
                                totalChildMass += newAsteroid.mass;
                            }

                            const deltaMomentumX = parentMomentumX - totalChildMomentumX;
                            const deltaMomentumY = parentMomentumY - totalChildMomentumY;

                            if (totalChildMass > 0) {
                                const correctionSpeedX = deltaMomentumX / totalChildMass;
                                const correctionSpeedY = deltaMomentumY / totalChildMass;

                                newAsteroids.forEach(child => {
                                    child.speedX += correctionSpeedX;
                                    child.speedY += correctionSpeedY;
                                });
                            }

                            asteroids.push(...newAsteroids);

                        } else {
                            // Drop ore, inheriting asteroid's speed
                            ores.push(new Ore(a.worldX, a.worldY, a.itemType, a.speedX, a.speedY));
                            showMessage(`${a.type} asteroid destroyed!`);
                        }
                    }

                    // Check for game over
                    if (player.hull <= 0) {
                        showGameOverMessage("Game Over! Your hull is breached.");
                        return; // Stop the animation loop for this frame
                    }
                }
            }

            // Update and draw ores
            for (let i = ores.length - 1; i >= 0; i--) {
                const o = ores[i];
                o.update(); // Update ore's world position
                o.draw();

                // Check for ore pickup using world coordinates
                const distToPlayer = getDistance(player.worldX, player.worldY, o.worldX, o.worldY);
                if (distToPlayer < player.radius + o.radius + ORE_PICKUP_RADIUS) {
                    if (player.addCargo(o.itemType)) {
                        ores.splice(i, 1); // Remove ore
                    }
                }
                // Remove old ore
                else if (o.lifespan <= 0) {
                    ores.splice(i, 1);
                }
            }

            // Draw player (always last to be on top)
            player.draw();

            // Draw the radar map
            drawRadar();

            gameFrame++;
        }

        // Planet Menu Logic
        function openPlanetMenu(planet) {
            isMenuOpen = true; // Set global menu flag
            isGamePaused = true; // Pause game when menu opens
            if (animationFrameId) { // Cancel pending animation frame
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            pauseMessage.style.display = 'none'; // Hide pause message when menu opens
            currentPlanet = planet; // Set the current planet for transactions
            planetMenu.style.display = 'flex';
            planetNameDisplay.textContent = `Docked at ${planet.name}`;
            updatePlanetMenu();
        }

        function closePlanetMenu() {
            isMenuOpen = false; // Clear global menu flag
            currentPlanet = null; // Clear current planet
            planetMenu.style.display = 'none';
            if (!isUserPaused && !isMenuOpen) { // If user wasn't paused and no other menu is open
                isGamePaused = false;
                if (!animationFrameId) { // Only request if not already running
                    animate(); // Resume animation loop
                }
            } else if (isUserPaused) { // If user was paused before menu, show pause message again
                pauseMessage.style.display = 'block';
            }
        }

        function updatePlanetMenu() {
            // Update credits display
            planetCreditsDisplay.textContent = player.credits.toFixed(0);

            // Clear lists
            buyList.innerHTML = '';
            sellList.innerHTML = '';

            if (!currentPlanet) return;

            // Populate Buy List
            for (const itemType in currentPlanet.inventory) {
                const itemData = currentPlanet.inventory[itemType];
                if (itemData.stock > 0) {
                    const listItem = document.createElement('li');
                    listItem.innerHTML = `
                        <span>${itemType}</span>
                        <span>Price: ${itemData.buyPrice} Cr</span>
                        <span>Stock: ${itemData.stock.toFixed(0)}</span> <button onclick="buyItem('${itemType}', 1)">Buy</button>
                        <button onclick="buyItem('${itemType}', 'max')">Buy Max</button>
                    `;
                    buyList.appendChild(listItem);
                }
            }

            // Populate Sell List
            for (const itemType in player.cargo) {
                const playerQty = player.cargo[itemType];
                if (playerQty > 0) {
                    const listItem = document.createElement('li');
                    const itemData = currentPlanet.inventory[itemType]; // Get item data from planet's inventory

                    if (itemData && itemData.sellPrice) { // If planet buys this item
                        listItem.innerHTML = `
                            <span>${itemType}</span>
                            <span>Qty: ${playerQty}</span>
                            <span>Price: ${itemData.sellPrice} Cr</span>
                            <button onclick="sellItem('${itemType}', 1)">Sell</button>
                            <button onclick="sellItem('${itemType}', 'all')">Sell All</button>
                        `;
                    } else { // If planet does not buy this item
                        listItem.innerHTML = `
                            <span>${itemType}</span>
                            <span>Qty: ${playerQty}</span>
                            <span class="not-purchased-label">Not Purchased</span>
                        `;
                    }
                    sellList.appendChild(listItem);
                }
            }
        }

        function buyItem(itemType, quantity = 1) {
            if (!currentPlanet || !currentPlanet.inventory[itemType]) return;

            const itemData = currentPlanet.inventory[itemType];
            const pricePerUnit = itemData.buyPrice;
            let actualQuantityToBuy = 0;

            if (quantity === 'max') {
                const maxByCredits = Math.floor(player.credits / pricePerUnit);
                const maxByStock = Math.floor(itemData.stock); // Use floor for available stock
                const maxByCargo = player.maxCargo - player.currentCargoWeight;
                actualQuantityToBuy = Math.min(maxByCredits, maxByStock, maxByCargo);
            } else {
                actualQuantityToBuy = quantity;
            }

            if (actualQuantityToBuy > 0) {
                const totalCost = actualQuantityToBuy * pricePerUnit;
                if (player.credits >= totalCost && itemData.stock >= actualQuantityToBuy && (player.currentCargoWeight + actualQuantityToBuy <= player.maxCargo)) {
                    player.credits -= totalCost;
                    player.addCargo(itemType, actualQuantityToBuy);
                    itemData.stock -= actualQuantityToBuy;
                    showMessage(`Bought ${actualQuantityToBuy} ${itemType} for ${totalCost} credits.`);
                    updatePlanetMenu();
                } else {
                    if (player.credits < totalCost) {
                        showMessage("Not enough credits!");
                    } else if (itemData.stock < actualQuantityToBuy) {
                        showMessage("Planet is out of stock!");
                    } else if (player.currentCargoWeight + actualQuantityToBuy > player.maxCargo) {
                        showMessage("Cargo hold full!");
                    }
                }
            } else {
                showMessage("Cannot buy more of this item.");
            }
        }

        function sellItem(itemType, quantity = 1) {
            if (!currentPlanet || !currentPlanet.inventory[itemType]) return;

            const itemData = currentPlanet.inventory[itemType];
            const pricePerUnit = itemData.sellPrice;
            let actualQuantityToSell = 0;

            if (quantity === 'all') {
                actualQuantityToSell = player.cargo[itemType] || 0;
            } else {
                actualQuantityToSell = quantity;
            }

            if (actualQuantityToSell > 0) {
                if (player.cargo[itemType] && player.cargo[itemType] >= actualQuantityToSell) {
                    const totalRevenue = actualQuantityToSell * pricePerUnit;
                    player.credits += totalRevenue;
                    player.removeCargo(itemType, actualQuantityToSell);
                    itemData.stock += actualQuantityToSell; // Planet gains stock
                    showMessage(`Sold ${actualQuantityToSell} ${itemType} for ${totalRevenue} credits.`);
                    updatePlanetMenu();
                } else {
                    showMessage("You don't have that item to sell!");
                }
            } else {
                showMessage("You don't have any of this item to sell!");
            }
        }

        // Shipyard Menu Logic
        function openShipyardMenu(station) {
            isMenuOpen = true; // Set global menu flag
            isGamePaused = true; // Pause game when menu opens
            if (animationFrameId) { // Cancel pending animation frame
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            pauseMessage.style.display = 'none'; // Hide pause message when menu opens
            currentSpaceStation = station;
            shipyardMenu.style.display = 'flex';
            shipyardNameDisplay.textContent = `Docked at ${station.name}`;
            updateShipyardMenu();
        }

        function closeShipyardMenu() {
            isMenuOpen = false; // Clear global menu flag
            currentSpaceStation = null;
            shipyardMenu.style.display = 'none';
            if (!isUserPaused && !isMenuOpen) { // If user wasn't paused and no other menu is open
                isGamePaused = false;
                if (!animationFrameId) { // Only request if not already running
                    animate(); // Resume animation loop
                }
            } else if (isUserPaused) { // If user was paused before menu, show pause message again
                pauseMessage.style.display = 'block';
            }
        }

        function updateShipyardMenu() {
            // Update credits display
            shipyardCreditsDisplay.textContent = player.credits.toFixed(0);

            upgradeList.innerHTML = ''; // Clear list

            // Hull Repair
            const hullRepairItem = document.createElement('li');
            const missingHull = player.maxHull - player.hull;
            const costPerUnit = UPGRADES['Hull Repair'].costPerUnit;

            let buttonText = "Repair All";
            let repairAmount = missingHull;
            let currentRepairCost = missingHull * costPerUnit;
            let isDisabled = false;

            if (missingHull === 0) {
                buttonText = "Hull Full";
                isDisabled = true;
                currentRepairCost = 0; // No cost if full
            } else if (player.credits < currentRepairCost) {
                const affordableHull = Math.floor(player.credits / costPerUnit);
                if (affordableHull > 0) {
                    buttonText = `Repair ${affordableHull.toFixed(0)}`;
                    repairAmount = affordableHull;
                    currentRepairCost = affordableHull * costPerUnit;
                } else {
                    buttonText = "Cannot Afford";
                    isDisabled = true;
                    repairAmount = 0; // No repair possible
                    currentRepairCost = 0; // No cost if cannot afford
                }
            }

            hullRepairItem.innerHTML = `
                <span>Hull Repair</span>
                <span>Current: ${player.hull.toFixed(0)}/${player.maxHull.toFixed(0)}</span>
                <span>Cost: ${currentRepairCost.toFixed(0)} Cr</span>
                <button onclick="UPGRADES['Hull Repair'].apply(${repairAmount})" ${isDisabled ? 'disabled' : ''}>${buttonText}</button>
            `;
            upgradeList.appendChild(hullRepairItem);

            // Other Upgrades
            for (const upgradeName in UPGRADES) {
                if (upgradeName === 'Hull Repair') continue; // Skip hull repair as it's handled above

                const upgrade = UPGRADES[upgradeName];
                const listItem = document.createElement('li');
                listItem.innerHTML = `
                    <span>${upgradeName}</span>
                    <span>${upgrade.display()}</span>
                    <button onclick="upgradeShip('${upgradeName}')">Upgrade</button>
                `;
                upgradeList.appendChild(listItem);
            }
        }

        function upgradeShip(upgradeName) {
            const upgrade = UPGRADES[upgradeName];
            if (upgrade && upgrade.apply()) {
                // If apply was successful, message is already shown by apply function
                updateShipyardMenu(); // Refresh menu to show new stats
            }
            // If apply was not successful, message is already shown by apply function
        }


        // Function to restart the game
        function restartGame() {
            // Explicitly close any open menus first
            closePlanetMenu();
            closeShipyardMenu();

            // Reset game state variables
            gameFrame = 0;
            projectiles = [];
            asteroids = [];
            ores = [];
            planets = [];
            spaceStations = []; // Reset space stations
            keys = {};
            lastShotFrame = 0;
            currentPlanet = null;
            currentSpaceStation = null; // Reset current space station
            dockableTargetCandidate = null; // Reset dockable target candidate
            isGameOver = false; // Reset game over flag

            // Reset pause states
            isGamePaused = false;
            isUserPaused = false;
            isMenuOpen = false;
            pauseMessage.style.display = 'none'; // Hide pause message

            // Re-initialize game entities
            initGame();
            hideMessage(); // Hide the game over message

            // Start the game loop again only if it's not already running
            if (!animationFrameId) {
                animate();
            }
        }


        // Start the game when the window loads
        window.onload = function () {
            initGame();

            // Event Listeners (moved here to be added only once)
            window.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                // Prevent default behavior for spacebar to avoid scrolling
                if (e.code === 'Space' && !isMenuOpen && !isGameOver) {
                    e.preventDefault();
                }
                // Handle 'E' key press to open/close planet or shipyard menu
                if (e.code === 'KeyE' && !isGameOver) {
                    if (isMenuOpen) { // If any menu is open, close it
                        if (currentPlanet) closePlanetMenu();
                        if (currentSpaceStation) closeShipyardMenu();
                    } else if (dockableTargetCandidate) { // Check the persistent candidate
                        if (dockableTargetCandidate.type === 'planet') {
                            openPlanetMenu(dockableTargetCandidate.entity);
                        } else if (dockableTargetCandidate.type === 'station') {
                            openShipyardMenu(dockableTargetCandidate.entity);
                        }
                    } else {
                        showMessage("No planet or station in range to dock."); // Provide feedback to user
                    }
                    keys['KeyE'] = false; // Consume key press to avoid re-triggering immediately
                }
                // Handle P or Escape key for pause/unpause
                if (e.code === 'KeyP' || e.code === 'Escape') {
                    if (!isGameOver) { // Cannot pause if game is over
                        // Toggle user pause state
                        isUserPaused = !isUserPaused;
                        isGamePaused = isUserPaused; // Game is paused if user wants it paused

                        if (isUserPaused) { // User wants to pause
                            if (animationFrameId) { // Cancel any pending animation frame
                                cancelAnimationFrame(animationFrameId);
                                animationFrameId = null;
                            }
                            // Explicitly show pause message if no menu is open
                            if (!isMenuOpen) {
                                pauseMessage.style.display = 'block';
                            }
                        } else { // User wants to unpause
                            // Explicitly hide pause message
                            pauseMessage.style.display = 'none';

                            // Only resume animation if no menu is open and animation isn't already running
                            if (!isMenuOpen && !animationFrameId) {
                                animate(); // Resume animation loop
                            }
                        }
                    }
                }
            });
            window.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });

            // Initial call to start the animation loop
            animate();
        };
    </script>
</body>
</html>
